[{"_id":"6372f9415c9b9d0271953000","question":"Reliability","answer":"making systems work correctly, even when faults occur. Faults can be in hardware, software, and humans","category":"databases","__v":0},{"_id":"6372f9655c9b9d0271953004","question":"Scalability","answer":"Being able to handle a higher volume of reads than a single machine could handle, by performing reads on replicas. Having strategies for keeping performance good, even when load increases.","category":"databases","__v":0},{"_id":"6372fa645c9b9d027195300e","question":"High Availability","answer":"Keeping the system running, even when one machine (or several machines, or an entire datacenter) goes down","category":"databases","__v":0},{"_id":"6372fa7b5c9b9d0271953010","question":"Disconnected Operation","answer":"Allowing an application to continue working when there is a network interruption","category":"databases","__v":0},{"_id":"6372fa925c9b9d0271953012","question":"Latency","answer":"Placing data geographically close to users, so that users can interact with it faster","category":"databases","__v":0},{"_id":"6372fb315c9b9d027195301e","question":"Single-leader Replication","answer":"Clients send all writes to a single node (the leader) which sends a stream of data change events to other replicas (followers). Reads can be performed on any replica, but reads from followers might be scale.","category":"databases","__v":0},{"_id":"6372fb615c9b9d0271953020","question":"Multi-leader Replication","answer":"Clients send each write to one of several leader nodes, any of which can accept writes. The leaders send streams of data change events to each other and to any follower nodes.","category":"databases","__v":0},{"_id":"6372fb8d5c9b9d0271953022","question":"Leaderless replication","answer":"Clients send each write to several nodes and read from several nodes in parallel in order to detect and correct nodes with stale data.","category":"databases","__v":0},{"_id":"6372fbb15c9b9d0271953024","question":"Read-after-write consistency","answer":"Users should always see data that that they submitted themselves.","category":"databases","__v":0},{"_id":"6372fbcf5c9b9d0271953026","question":"Monotonic reads","answer":"After users have seen the data at one point in time they shouldnt later see the data from some earlier point in time.","category":"databases","__v":0},{"_id":"6372fbf55c9b9d0271953028","question":"Consistent prefix reads","answer":"Users should see the data in a state that makes causal sense: for example, seeing a question and its reply in the correct order.","category":"databases","__v":0},{"_id":"6372fdbf5c9b9d027195302e","question":"Key Range Partitioning","answer":"Where keys are sorted, and a partition owns all the keys from some minimum up to some maximum. Sorting has the advantage that efficient range queries are possible, but there is a risk of hot spots if the application often accesses keys that are close together in sorted order.","category":"databases","__v":0},{"_id":"6372fdf75c9b9d0271953030","question":"Hash Partitioning","answer":"Where a hash function is applied to each key, and a partition owns a range of hashes. This method destroys the ordering of keys, making range queries inefficient, but may distribute load more evenly.","category":"databases","__v":0},{"_id":"6372fe645c9b9d0271953032","question":"Document-partitioned Indexes (local indexes)","answer":"Where the secondary indexes are stored in the same partition as the primary key and value. This means that only a single partition needs to be updated on write, but a read of the secondary index requires a scatter/gather across all partitions","category":"databases","__v":0},{"_id":"6372fed45c9b9d0271953034","question":"Term-partitioned Indexes (local indexes)","answer":"Where the secondary indexes are partitioned separately, using the indexed values. An entry in the secondary index may include records from all partitions of the primary key. When a document is written, several partitions of the secondary index need to be updated; however, a read can be served from a single partition.","category":"databases","__v":0},{"_id":"6372ff1f5c9b9d0271953038","question":"Dirty Reads","answer":"One client reads another client's writes before they have been committed. The read committed isolation level and stronger levels prevent dirty reads.","category":"databases","__v":0,"subcategory":"Transactions"},{"_id":"6372ff465c9b9d027195303a","question":"Dirty Writes","answer":"One client overwrites data that another client has written, but not yet committed. Almost all transaction implementations prevent dirty writes","category":"databases","__v":0,"subcategory":"Transactions"},{"_id":"6372ffb45c9b9d027195303c","question":"Read Skew","answer":"A client sees different parts of the database at different points in time. Some cases of read skew are also known as non repeatable reads. this issue is most commonly prevented with snapshot isolation, which allows a transaction to read from a consistent snapshot corresponding to one particular point in time. It is usually implemented with multi-version concurrency control (MVCC)","category":"databases","__v":0,"subcategory":"Transactions"},{"_id":"6373002b5c9b9d0271953046","question":"Lost Updates","answer":"Two clients concurrently perform a read-modify-write cycle. One overwrites the other's write without incorporating its changes, so data is lost. Some implementations of snapshot isolation prevent this anomaly automatically, while others require a manual lock (SELECT FOR UPDATE)","category":"databases","__v":0},{"_id":"637300715c9b9d0271953048","question":"Write Skew","answer":"A transaction reads something, makes a decision based on the value it saw, and writes the decision to the database. However,by the time the write is made, the premise of the decision is no longer true. Only serializable isolation prevents this anomaly","category":"databases","__v":0},{"_id":"637300bb5c9b9d027195304a","question":"Phantom Read","answer":"A transaction reads objects that match some search condition. Another client makes a write that affects the results of that search. Snapshot isolation prevents straightforward phantom reads, but phantoms in context of write skew require special treatment, such as index-range locks.","category":"databases","__v":0},{"_id":"637301015c9b9d027195304c","question":"Literally executing transactions in a serial order","answer":"If you can make each transaction very fast to execute, and the transaction throughput is low enough to process a single CPU core, this is a simple and effective option","category":"databases","__v":0},{"_id":"6373012e5c9b9d027195304e","question":"Two-phase locking","answer":"For decades this has ben the standard way of implementing serializability, but many applications avoid using it because of its performance characteristics.","category":"databases","__v":0},{"_id":"6373019e5c9b9d0271953050","question":"Serializable Snapshot Isolation (SSI)","answer":"A fairly new algorithm that avoids most of the downsides of the previous approaches. It uses an optimistic approach, allowing transactions to proceed without blocking. It uses an optimistic approach, allowing transactions to proceed without blocking. When a transaction wants to commit, it is checked, and it si aborted if the execution was not serializable","category":"databases","__v":0},{"_id":"637301b15c9b9d0271953052","question":"Serialization","answer":"is the process of translating a data structure or object state into a format that can be stored or transmitted and reconstructed later.","category":"","__v":0}]